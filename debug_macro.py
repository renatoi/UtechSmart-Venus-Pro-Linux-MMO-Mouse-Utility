#!/usr/bin/env python3
"""
Compare macro packets generated by venus_protocol.py against USB capture data.
This helps identify discrepancies causing macros to not work.
"""

import venus_protocol as vp

# From capture: "wired - rebind 1 to macro called testing"
# Button 1, apply_offset 0x60, macro "testing" (7 keys: t,e,s,t,i,n,g)
CAPTURE_PACKETS = [
    # Format: (description, hex_string_from_capture)
    ("Prepare", "080300000000000000000000000000004a"),
    ("Reset?", "0809000000000000000000000000000044"),  # Appears before macro write
    ("Prepare2", "080300000000000000000000000000004a"),
    ("Name0", "08070003000a0e74006500730074006902"),  # Page 03, Offset 00
    ("Name10", "080700030a0a006e00670000000000005a"),  # Page 03, Offset 0A
    ("Name20", "08070003140a0000000000000000000025"),  # Page 03, Offset 14
    ("Event1E", "080700031e0a000e811700005d411700c0"),  # Offset 1E - T key
    ("Event28", "08070003280a009d810800005d41080045"),  # Offset 28 - E key
    ("Event32", "08070003320a00bc811600006d411600f0"),  # Offset 32 - S key
    ("Event3C", "080700033c0a009c811700005e41170013"),  # Offset 3C - T key
    ("Event46", "08070003460a009c810c00005e410c001f"),  # Offset 46 - I key
    ("Event50", "08070003500a00bc811100004e411100fb"),  # Offset 50 - N key
    ("Event5A", "080700035a0a00cb810a00005e410a00e0"),  # Offset 5A - G key
    ("Terminator", "080700036406000369000000000000006d"),  # Offset 64
    ("Bind", "0807000060040600014e0000000000008d"),  # Apply, Type 06, Index 01
    ("Commit", "0804000000000000000000000000000049"),
]


def analyze_name_packet(hex_str: str) -> dict:
    """Parse a name chunk packet."""
    data = bytes.fromhex(hex_str)
    return {
        "report_id": data[0],
        "cmd": data[1],
        "page": data[3],
        "offset": data[4],
        "length": data[5],
        "content": data[6:16].hex(),
        "checksum": data[16],
    }


def analyze_event_packet(hex_str: str) -> dict:
    """Parse an event data packet."""
    data = bytes.fromhex(hex_str)
    chunk = data[6:16]
    return {
        "page": data[3],
        "offset": data[4],
        "length": data[5],
        "raw_chunk": chunk.hex(),
        # Try to decode as events (5 bytes each)
        "event1_delay": (chunk[0] << 8) | chunk[1] if len(chunk) >= 2 else None,
        "event1_status": chunk[2] if len(chunk) >= 3 else None,
        "event1_key": chunk[3] if len(chunk) >= 4 else None,
        "event2_delay": (chunk[5] << 8) | chunk[6] if len(chunk) >= 7 else None,
        "event2_status": chunk[7] if len(chunk) >= 8 else None,
        "event2_key": chunk[8] if len(chunk) >= 9 else None,
    }


def generate_my_packets():
    """Generate packets using current venus_protocol implementation."""
    # Simulate what _upload_macro does for "testing" macro on Button 1
    name = "test"  # 4 chars (8 bytes UTF16)
    
    # Encode name
    name_bytes = name.encode("utf-16le")
    
    # Build buffer
    buf = bytearray(0x70)
    buf[0] = len(name_bytes)
    buf[1:1+len(name_bytes)] = name_bytes
    
    # Add events for "testing" - T, E, S, T, I, N, G
    # Each event is down then up, 10 bytes total (5+5)
    test_keys = [
        # (keycode, delay_down, delay_up) - from capture analysis
        (0x17, 14, 93),   # T
        (0x08, 157, 93),  # E
        (0x16, 188, 109), # S
        (0x17, 156, 94),  # T
        (0x0C, 156, 94),  # I
        (0x11, 188, 78),  # N
        (0x0A, 203, 94),  # G
    ]
    
    event_offset = 0x1E
    for keycode, delay_prev, delay_up in test_keys:
        # Down event
        down_event = vp.MacroEvent(keycode=keycode, is_down=True, delay_ms=delay_prev)
        down_bytes = down_event.to_bytes()
        buf[event_offset:event_offset+len(down_bytes)] = down_bytes
        event_offset += len(down_bytes)
        
        # Up event
        up_event = vp.MacroEvent(keycode=keycode, is_down=False, delay_ms=delay_up)
        up_bytes = up_event.to_bytes()
        buf[event_offset:event_offset+len(up_bytes)] = up_bytes
        event_offset += len(up_bytes)
    
    # Button 1: apply_offset = 0x60
    apply_offset = 0x60
    macro_page = vp.get_macro_page(apply_offset)
    
    print(f"Calculated macro page: 0x{macro_page:02X}")
    print(f"Name bytes: {name_bytes.hex()}")
    print(f"Buffer[0:0x20]: {buf[0:0x20].hex()}")
    print(f"Buffer[0x1E:0x30]: {buf[0x1E:0x30].hex()}")
    
    # Generate packets
    packets = []
    
    # Chunks
    for offset in range(0x00, 0x64, 0x0A):
        chunk = bytes(buf[offset:offset+10])
        pkt = vp.build_macro_chunk(offset, chunk, macro_page)
        packets.append((f"Chunk_{offset:02X}", pkt))
    
    # Terminator
    packets.append(("Terminator", vp.build_macro_terminator(macro_page)))
    
    # Bind
    packets.append(("Bind", vp.build_macro_bind(apply_offset, macro_index=1)))
    
    return packets


def compare_packets():
    """Compare capture vs generated packets."""
    print("=" * 80)
    print("CAPTURE ANALYSIS")
    print("=" * 80)
    
    for name, hex_str in CAPTURE_PACKETS:
        if "Event" in name or "Name" in name:
            info = analyze_event_packet(hex_str)
            print(f"{name}: Page=0x{info['page']:02X} Offset=0x{info['offset']:02X} Len={info['length']} Data={info['raw_chunk']}")
        elif name == "Bind":
            data = bytes.fromhex(hex_str)
            print(f"{name}: {hex_str}")
            print(f"  Offset=0x{data[4]:02X} Type=0x{data[5]:02X} FlashIdx=0x{data[6]:02X} MacroIdx=0x{data[7]:02X} ActionCode=0x{data[8]:02X}")
        else:
            print(f"{name}: {hex_str}")
    
    print("\n" + "=" * 80)
    print("GENERATED PACKETS")
    print("=" * 80)
    
    my_packets = generate_my_packets()
    for name, pkt in my_packets:
        hex_str = pkt.hex()
        if "Chunk" in name:
            data = pkt
            print(f"{name}: Page=0x{data[3]:02X} Offset=0x{data[4]:02X} Len={data[5]} Data={data[6:16].hex()}")
        elif name == "Bind":
            data = pkt
            print(f"{name}: {hex_str}")
            print(f"  Offset=0x{data[4]:02X} Type=0x{data[5]:02X} FlashIdx=0x{data[6]:02X} MacroIdx=0x{data[7]:02X} ActionCode=0x{data[8]:02X}")
        else:
            print(f"{name}: {hex_str}")
    
    print("\n" + "=" * 80)
    print("KEY DIFFERENCES")
    print("=" * 80)
    
    # Key comparison: Event structure
    print("\nCapture Event1E (T key):")
    cap_e1 = bytes.fromhex("080700031e0a000e811700005d411700c0")[6:16]
    print(f"  Raw: {cap_e1.hex()}")
    print(f"  Byte breakdown: {' '.join(f'{b:02X}' for b in cap_e1)}")
    print(f"  Interpretation:")
    print(f"    Bytes 0-1: {cap_e1[0]:02X} {cap_e1[1]:02X} = Delay {(cap_e1[0]<<8)|cap_e1[1]} ms?")
    print(f"    Byte 2: {cap_e1[2]:02X} = Status (81=Down)")
    print(f"    Byte 3: {cap_e1[3]:02X} = Keycode (17=T)")
    print(f"    Bytes 4-5: {cap_e1[4]:02X} {cap_e1[5]:02X} = Padding or Delay2?")
    print(f"    Byte 6: {cap_e1[6]:02X} = ?")
    print(f"    Byte 7: {cap_e1[7]:02X} = Status (41=Up)")
    print(f"    Byte 8: {cap_e1[8]:02X} = Keycode (17=T)")
    print(f"    Byte 9: {cap_e1[9]:02X} = Padding")


if __name__ == "__main__":
    compare_packets()
